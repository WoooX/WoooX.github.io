[{"title":"JAVA线程池ThreadPoolExecutor","date":"2017-03-25T06:49:01.000Z","path":"2017/03/25/JAVA线程池ThreadPoolExecutor/","text":"最近打算体系的看下java并发包的源码,前两天把线程池的核心类ThreadPoolExecutor的源码过了一遍,今天做个记录总结。 个人认为的并发包主要可以分为线程池、线程安全集合、原子操作类、线程通信4个功能模块。其中ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue等属于线程安全集合；AtomicBoolean、AtomicLong等属于原子操作类；Exchanger、ReentrantLock、CountDownLatch等属于线程通信。 而本次研究的ThreadPoolExecutor则属于实现线程池的核心类,首先可以先看下线程池的类图如下: 其中真正和线程池相关的是从ThreadPoolExecutor及其相关的子类们(其实也就一个ScheduledThreadPoolExecutor ~.~)。而像Executor、ExecutorService这些接口其实和线程池没什么关系,他们只是重新定义了一种并发编程模型,可以对比的是之前的Thread。不过这个重新定义的模型功能会比Runnable来得丰富,比如ExecutorService可以获取执行结果(也就是线程执行结果,Runnable是无法获取执行结果的)、ScheduleExecutorService可以定时执行任务等(以前的方式需要通过Timer来实现)。而线程池应该算是这个执行模型中引入的一个非常重要的功能,由ThreadPoolExecutor提供了基本的实现,我们也可以通过继承ThreadPoolExecutor来实现自定义的线程池,实际上ThreadPoolExecutor也提供了很多hook函数来让我们自定义,这个后面再说。 (注:java中的并发/并行编程模型有四种(我所知道的 ~.~):Thread、Executor、ForkJoin模型、Actor模型。具体可以参考这篇文章Java并发的四种风味) 然后在说回线程池,线程池作为一种池化技术其实出现已经很久了。池化主要针对一些比较”重”(我不清楚这里用重合不合理,能看懂就行)的资源进行缓存重复利用,比如连接池、线程池等。下面就看下实现线程池的代码,代码基于JDK1.8。 构造函数和关键属性构造函数: 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor一共4个构造函数,但最终都会调用上面这个构造函数,其中: corePoolSize 这个是用来控制池中工作线程个数的参数 maximumPoolSize 这个也是用来控制工作线程个数参数,表示的是最大线程数 上面两个参数都是用来控制控制工作线程的参数,但是他们的含义是有差别的 －①－(corePoolSize)－②－(maximumPoolSize)－③— 有点类似上面的一条直线,corePoolSize和maximumPoolSize切直线为三段。当池内的工作线程数处于①时线程池会在接收到任务时持续增长到corePoolSize大小(不会利用已有的线程及即使线程是空闲的);然后线程池的线程个数会慢慢增长到②,这时线程池会在每次接受到任务时会优先查找池内的空闲线程,只有在找不到空闲线程时才增加新线程到线程池中执行新任务;最后一旦线程池增大到maximumPoolSize的大小时,线程池会开始拒绝执行新任务(拒绝策略可配置),所以③是不可能出现的情况。 ps:注意这里说的任务和线程这是有区别的,后面会说到 keepAliveTime 这个是用来控制池内空闲线程存活时间的,这个参数在前面讲到的线程个数处于①时是不起作用的 unit 这个和keepAliveTime配合使用的,没啥好说的 threadFactory 采用工厂模式生成线程,可以看下ThreadFactory接口其实就一个newThread方法 handler 这个是拒绝策略 理论上而会出现线程拒绝任务的情况需要满足两个条件,除了上面讨论到的线程个数达到了maximumPoolSize之外,还需要任务队列也满了才会出现拒绝的情况。不过事实上一旦线程达到maximumPoolSize的话队列肯定也是满的,这是因为代码前后逻辑顺序的原因,后面看代码就会知道。至于具体的策略,官方提供了四种AbortPolicy(默认,在调用线程内抛异常)、CallerRunsPolicy(在调用线程内执行该任务)、DiscardPolicy(简单抛弃不做任何事)、DiscardOldestPolicy(抛弃任务队列中最旧执行当前任务) 除了构造函数的几个参数外,还有几个重要的参数 ctl 一个控制变量,这个应该是算是整个实现里最重要的一个属性了,包含了线程池的状态信息和线程的数量信息 12345678910private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 可以看出线程池的状态有5种——RUNNING, SHUTDOWN, STOP, TIDYING, TERMINATED RUNNING : 运行正常,可以正正常接受新任务SHUTDOWN : 不接受新任务,执行已缓存的任务然后关闭线程池STOP : 不接受新任务,中断已缓存的任务然后关闭线程池TIDYING : 当任务都结束了(正常执行完/中断完),即SHUTDOWN和STOP状态后面都会到TIDYING状态TERMINATED : 这个是因为提供了terminated()钩子函数,所以只有在执行了这个函数之后才会到TERMINATED状态;不过默认实现TIDYING状态即正常关闭了因为erminated()是个空方法 需要注意的是状态信息是和线程池的线程个数一起存放在了ctl属性里,其中高3位表示状态信息(5个状态最少需要3位共可表示9种状态);低29位表示工作线程个数,共可表示2^29-1个线程大小。 而这样实现的好处主要可以节省空间,而且因为数量信息存在低位,ctl的加减运算即为线程数的加减法,可看下面关于ctl操作的代码 123456789101112131415161718192021222324252627//取高3位得到状态信息 c &amp; 0x70000000private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; //取低29位得到数量信息 c &amp; 0x07777777private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//状态信息和数量信息合并存于ctlprivate static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;//数量加1,可以发现只需要ctl+1即可private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1); &#125;//数量减1,同上只需要ctl-1即可private boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1); &#125;private void decrementWorkerCount() &#123; do &#123;&#125; while (!compareAndDecrementWorkerCount(ctl.get())); &#125;//下面几个是静态方法主要用来判断的private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125; workQueue 这个是用来存放执行任务的阻塞队列 其实个人觉得这个参数的命名并不准确,这个应该称为taskQueue会更合适一点;需要注意的是这个任务队列和corePoolSize、maximumPoolSize是没有关系的,这两个参数表示的是工作线程的容量大小,是和下面会说到的works的大小相关的;而队列相关是执行的任务,执行任务本身是不会启动线程的(虽然他的类型是Runnable,但是直接调用Runnable的run是不启动新线程的),这些是在worker启动的线程中被执行的 workers 存放缓存线程的集合 这个才是和corePoolSize、maximumPoolSize是有关系的,表示的是工作线程的集合。但是实际上真正启动线程的是worker内部类型为Thread的一个参数t,就是ThreadFactory返回的那个线程,而newThread方法传入的参数就是worker本身。所以可以尝试下,如果自定义实现ThreadFactory,然后在返回线程时不使用传入的那个Runnable参数这时线程池是不会正常工作的。代码如下 123456789101112131415161718192021222324252627private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; private static final long serialVersionUID = 6138294804551838833L; //这里就是通过工厂返回的线程对象 final Thread thread; //这里就是该工作线程第一个执行的任务&#123;注意这里用词:第一个&#125; Runnable firstTask; //一个统计信息 volatile long completedTasks; Worker(Runnable firstTask) &#123; setState(-1); this.firstTask = firstTask; //就是在这里调用了工厂生成线程 this.thread = getThreadFactory().newThread(this); &#125; //这里就是线程具体执行的地方了,他调用了ThreadPoolExecutor的方法runWorker方法;当然前提是工厂的返回的线程要基于传入的Runnable也就是worker本身来生成线程 public void run() &#123; runWorker(this); &#125; ... &#125; mainLock 这个是内部使用的一个锁 123private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();private final Condition termination = mainLock.newCondition();private int largestPoolSize; 需要注意的是上面三个属性的类型,很明显这三个属性是线程不安全的,既然扯到线程不安全就很明显了,对这三个属性的操作是需要同步的。而到观察源码也可以发现锁的使用基本就是在处理这三个参数的时候了,不过有少数几个情况的锁的使用可以拿出来探讨的,后面再说 核心逻辑启动线程池 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //A. int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //B. if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //C. else if (!addWorker(command, false)) reject(command); &#125; 上面是启动线程池的方法(submit也是调用的该方法的),这个方法里主要有三种情况,对应A、B、C三处代码(源码英文注释也有说) A : 这个比较好理解，其实就对应着前面①的情况,这个时候时候无论有没有空闲线程都是需要新增工作线程的B : 这个是②的情况,任务队列是可以插入任务的;会发现即使插入成功后还是会在做一次判断,这是因为在并发环境下我们无法预测执行的操作,可能在插入成功后,有个操作把线程池给停了(而且在插入成功后执行了),根据状态的定义处于不处于RUNNING状态的话是不能接受新任务的,所以需要把任务取消掉;又或者插入成功后,工作线程刚好都因为空闲且超出了KeepAlive时间而被关闭了,我们知道任务是不启动新线程的,所以即使插入了任务但是没有活跃的工作线程也无法执行,所以需要添加一个新的工作线程C : 这个是处于②或③的情况。②是因为队列满了不过线程池还没满可以在增加线程;③其实就是队列满了线程池也满了,这个时候是肯定会执行reject的然后可以发现具体执行新增线程的方法是addWorker。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private boolean addWorker(Runnable firstTask, boolean core) &#123; //第一部分 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; //第二部分 boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; 这个方法很长,不过也不清楚要去掉哪些就全部贴出来了.这个方法的逻辑主要分两部分,第一部分属于条件判断,判断是否可以执行第二部分的新增工作线程的逻辑。首先判断的是线程池的状态,根据对线程池的状态定义只有RUNNING状态的线程池才会接受新任务,所以这边判断只有处于RUNNING状态或者处于SHUTDOWN状态传入的任务为空时为后执行否则返回false,之所以还会有个或者….是因为这个时候传入的任务是空符合SHUTDOWN不接受新任务的要求而且SHUTDOWN是可以执行完已有任务的,所以这种情况会运行然后生成没有首任务的线程来执行。然后判断的是线程池内的线程个数,这边利用的是CAS+循环的方式来控制,只有当成功执行ctl+1之后才会跳出循环。判断完成后就会进行生成线程和执行线程的工作,工作线程由Worker类型来抽象,这是一个Runnable实现类内部持有一个Thread类型属性t和一个Runable类型属性firstTask,具体的线程由属性t来启动，线程启动后就进入执行任务的逻辑中了 关闭线程池 1234567891011121314151617181920212223242526272829public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); &#125; public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks; &#125; 有两种关闭线程的方法,他们最主要的区别就是会使得线程池处于不同的状态中,shutdown会使线程池处于SHUTDOWN状态,这时线程池不接受新任务但会执行完已有的任务;而shutdownNow则使线程池处于STOP状态,这时线程池不仅不接受新任务还会中断掉所有正在运行的线程,已保存但未执行的任务是不会执行的。然后最后二者都会调用tryTerminate方法使线程池处于TIDYING状态最后处于TERMINATED状态完全关闭 任务如何被执行 上面说明了对线程池是如何启动和关闭的,针对的对象主要是线程。而现在在来看下这些被启动的线程是如何执行任务的，执行任务的逻辑主要在runWorker方法中,如下: 123456789101112131415161718192021222324252627282930313233343536373839final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; 可以看到这个方法核心逻辑是个循环, firstTask是工作线程的第一个任务(即execute传入的Runnable),而getTasks()主要是从任务队列中取出任务,所以很明显线程会在获取不到task时跳出循环然后执行结束,也就是线程池中的工作线程会在获取不到任务时结束。而循环内的逻辑是很简单的，就是调用task的run方法(注:Runnable的run方法是不会启动线程的,线程需要由Thread的start方法启动),加上前后的两个钩子方法beforeExecute/afterExecute。最后会执行线程退出逻辑。 keepAliveTime如何实现 构造函数的时候有个参数keepAliveTime,指的是空闲线程的存活时间。而上面任务执行的时候有说到一个getTasks()方法,当该方法得不到任务时线程会退出。具体的keepAliveTime就在该方法中实现: 12345678910111213141516171819202122232425262728293031323334353637private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 这个方法的核心逻辑又是个循环(注:CAS原理+循环经常用来实现自旋锁)，循环内第一个判断的逻辑主要是当线程池当前不是SHUTDOWN、RUNNING时或者线程池当前是SHUTDOWN且任务队列为空执行分支代码。然后timed就是用来实现前面说的当线程个数小于corePoolSize时keepAliveTime是不起作用的。在然后的一个判断就是在超时的时候返回null(有个compareAndDecrementWorkerCount主要是因为并发)从而让线程退出。在然后就是进行超时的判断了,借助了阻塞队列的poll方法","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"并发包","slug":"并发包","permalink":"http://yoursite.com/tags/并发包/"}]}]