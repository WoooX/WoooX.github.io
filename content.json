[{"title":"JAVA线程池ThreadPoolExecutor","date":"2017-03-25T06:49:01.000Z","path":"2017/03/25/JAVA线程池ThreadPoolExecutor/","text":"最近打算体系的看下java并发包的源码,前两天把线程池的核心类ThreadPoolExecutor的源码过了一遍,今天做个记录总结。 个人认为的并发包主要可以分为线程池、线程安全集合、原子操作类、线程通信4个功能模块。其中ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue等属于线程安全集合；AtomicBoolean、AtomicLong等属于原子操作类；Exchanger、ReentrantLock、CountDownLatch等属于线程通信。 而本次研究的ThreadPoolExecutor则属于实现线程池的核心类,首先可以先看下线程池的类图如下: 其中真正和线程池相关的是从ThreadPoolExecutor及其相关的子类们(其实也就一个ScheduledThreadPoolExecutor ~.~)。而像Executor、ExecutorService这些接口其实和线程池没什么关系,他们只是重新定义了一种并发编程模型,可以对比的是之前的Thread。不过这个重新定义的模型功能会比Runnable来得丰富,比如ExecutorService可以获取执行结果(也就是线程执行结果,Runnable是无法获取执行结果的)、ScheduleExecutorService可以定时执行任务等(以前的方式需要通过Timer来实现)。而线程池应该算是这个执行模型中引入的一个非常重要的功能,由ThreadPoolExecutor提供了基本的实现,我们也可以通过继承ThreadPoolExecutor来实现自定义的线程池,实际上ThreadPoolExecutor也提供了很多hook函数来让我们自定义,这个后面再说。 (注:java中的并发/并行编程模型有四种(我所知道的 ~.~):Thread、Executor、ForkJoin模型、Actor模型。具体可以参考这篇文章Java并发的四种风味) 然后在说回线程池,线程池作为一种池化技术其实出现已经很久了。池化主要针对一些比较”重”(我不清楚这里用重合不合理,能看懂就行)的资源进行缓存重复利用,比如连接池、线程池等。下面就看下实现线程池的代码,代码基于JDK1.8。 构造函数和关键属性构造函数: 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor一共4个构造函数,但最终都会调用上面这个构造函数,其中: corePoolSize 这个是用来控制池中工作线程个数的参数 maximumPoolSize 这个也是用来控制工作线程个数参数,表示的是最大线程数 上面两个参数都是用来控制控制工作线程的参数,但是他们的含义是有差别的 －①－(corePoolSize)－②－(maximumPoolSize)－③— 有点类似上面的一条直线,corePoolSize和maximumPoolSize切直线为三段。当池内的工作线程数处于①时线程池会在接收到任务时持续增长到corePoolSize大小(不会利用已有的线程及即使线程是空闲的);然后线程池的线程个数会慢慢增长到②,这时线程池会在每次接受到任务时会优先查找池内的空闲线程,只有在找不到空闲线程时才增加新线程到线程池中执行新任务;最后一旦线程池增大到maximumPoolSize的大小时,线程池会开始拒绝执行新任务(拒绝策略可配置),所以③是不可能出现的情况。 ps:注意这里说的任务和线程这是有区别的,后面会说到 keepAliveTime 这个是用来控制池内空闲线程存活时间的,这个参数在前面讲到的线程个数处于①时是不起作用的 unit 这个和keepAliveTime配合使用的,没啥好说的 threadFactory 采用工厂模式生成线程,可以看下ThreadFactory接口其实就一个newThread方法 handler 这个是拒绝策略 理论上而会出现线程拒绝任务的情况需要满足两个条件,除了上面讨论到的线程个数达到了maximumPoolSize之外,还需要任务队列也满了才会出现拒绝的情况。不过事实上一旦线程达到maximumPoolSize的话队列肯定也是满的,这是因为代码前后逻辑顺序的原因,后面看代码就会知道。至于具体的策略,官方提供了四种AbortPolicy(默认,在调用线程内抛异常)、CallerRunsPolicy(在调用线程内执行该任务)、DiscardPolicy(简单抛弃不做任何事)、DiscardOldestPolicy(抛弃任务队列中最旧执行当前任务) 除了构造函数的几个参数外,还有几个重要的参数 ctl 一个控制变量,这个应该是算是整个实现里最重要的一个属性了,包含了线程池的状态信息和线程的数量信息 12345678910private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 可以看出线程池的状态有5种——RUNNING, SHUTDOWN, STOP, TIDYING, TERMINATED RUNNING : 运行正常,可以正正常接受新任务SHUTDOWN : 不接受新任务,执行已缓存的任务然后关闭线程池STOP : 不接受新任务,中断已缓存的任务然后关闭线程池TIDYING : 当任务都结束了(正常执行完/中断完),即SHUTDOWN和STOP状态后面都会到TIDYING状态TERMINATED : 这个是因为提供了terminated()钩子函数,所以只有在执行了这个函数之后才会到TERMINATED状态;不过默认实现TIDYING状态即正常关闭了因为erminated()是个空方法 需要注意的是状态信息是和线程池的线程个数一起存放在了ctl属性里,其中高3位表示状态信息(5个状态最少需要3位共可表示9种状态);低29位表示工作线程个数,共可表示2^29-1个线程大小。 而这样实现的好处主要可以节省空间,而且因为数量信息存在低位,ctl的加减运算即为线程数的加减法,可看下面关于ctl操作的代码 123456789101112131415161718192021222324252627//取高3位得到状态信息 c &amp; 0x70000000private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; //取低29位得到数量信息 c &amp; 0x07777777private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//状态信息和数量信息合并存于ctlprivate static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;//数量加1,可以发现只需要ctl+1即可private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1); &#125;//数量减1,同上只需要ctl-1即可private boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1); &#125;private void decrementWorkerCount() &#123; do &#123;&#125; while (!compareAndDecrementWorkerCount(ctl.get())); &#125;//下面几个是静态方法主要用来判断的private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125; workQueue 这个是用来存放执行任务的阻塞队列 其实个人觉得这个参数的命名并不准确,这个应该称为taskQueue会更合适一点;需要注意的是这个任务队列和corePoolSize、maximumPoolSize是没有关系的,这两个参数表示的是工作线程的容量大小,是和下面会说到的works的大小相关的;而队列相关是执行的任务,执行任务本身是不会启动线程的(虽然他的类型是Runnable,但是直接调用Runnable的run是不启动新线程的),这些是在worker启动的线程中被执行的 workers 存放缓存线程的集合 这个才是和corePoolSize、maximumPoolSize是有关系的,表示的是工作线程的集合。但是实际上真正启动线程的是worker内部类型为Thread的一个参数t,就是ThreadFactory返回的那个线程,而newThread方法传入的参数就是worker本身。所以可以尝试下,如果自定义实现ThreadFactory,然后在返回线程时不使用传入的那个Runnable参数这时线程池是不会正常工作的。代码如下 123456789101112131415161718192021222324252627private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; private static final long serialVersionUID = 6138294804551838833L; //这里就是通过工厂返回的线程对象 final Thread thread; //这里就是该工作线程第一个执行的任务&#123;注意这里用词:第一个&#125; Runnable firstTask; //一个统计信息 volatile long completedTasks; Worker(Runnable firstTask) &#123; setState(-1); this.firstTask = firstTask; //就是在这里调用了工厂生成线程 this.thread = getThreadFactory().newThread(this); &#125; //这里就是线程具体执行的地方了,他调用了ThreadPoolExecutor的方法runWorker方法;当然前提是工厂的返回的线程要基于传入的Runnable也就是worker本身来生成线程 public void run() &#123; runWorker(this); &#125; ... &#125; mainLock 这个是内部使用的一个锁 123private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();private final Condition termination = mainLock.newCondition();private int largestPoolSize; 需要注意的是上面三个属性的类型,很明显这三个属性是线程不安全的,既然扯到线程不安全就很明显了,对这三个属性的操作是需要同步的。而到观察源码也可以发现锁的使用基本就是在处理这三个参数的时候了,不过有少数几个情况的锁的使用可以拿出来探讨的,后面再说 关键操作线程池作为一个管理线程的容器,关键操作也就是启动关闭了 启动线程池 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //A. int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //B. if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //C. else if (!addWorker(command, false)) reject(command); &#125; 上面是启动线程池的方法(submit也是调用的该方法的),这个方法里主要有三种情况(源码英文注释也有说) A : 这个比较好理解，其实就对应着前面①的情况,这个时候时候无论有没有空闲线程都是需要新增工作线程的B : 这个是②的情况,任务队列是可以插入任务的;会发现即使插入成功后还是会在做一次判断,这是因为在并发环境下我们无法预测执行的操作,可能在插入成功后,有个操作把线程池给停了(而且在插入成功后执行了),根据状态的定义处于不处于RUNNING状态的话是不能接受新任务的,所以需要把任务取消掉;又或者插入成功后,工作线程刚好都因为空闲且超出了KeepAlive时间而被关闭了,我们知道任务是不启动新线程的,所以即使插入了任务但是没有活跃的工作线程也无法执行,所以需要添加一个新的工作线程C : 这个是处于②或③的情况。②是因为队列满了不过线程池还没满可以在增加线程;③其实就是队列满了线程池也满了,这个时候是肯定会执行reject的","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"并发包","slug":"并发包","permalink":"http://yoursite.com/tags/并发包/"}]}]