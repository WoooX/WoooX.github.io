[{"title":"JAVA并发包之ThreadPoolExecutor","date":"2017-03-25T06:49:01.000Z","path":"2017/03/25/JAVA并发包之ThreadPoolExecutor/","text":"之前把java并发包中一些类的源码看了一遍，趁着有时间做下笔记 首先说下并发包，所谓并发包指的就是java.util.concurrent。下面是通过IDEA截出来的这个包下部分截图。 可以看到包括了大量的类和接口以及两个子包–atomic和lock，不过个人觉得jdk中这样的组织方式并不是很好理解，太多的类被集中放在了java.util.concurrent包下了，所以就按照个人的理解对并发包下的类和接口重新做了分类。经过组织觉得并发包下的内容可以分为下面四方面内容: 线程安全集合，主要包括了ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue等，这些都被放在了java.util.concurrent包下、 原子操作类，主要包括了AtomicBoolean、AtomicLong等，这些都被放在了java.util.concurrent.atomic包下、 线程通信，主要有线程间的数据交换、线程同步如Exchanger、ReentrantLock、CountDownLatch等，这些分别被放在了java.util.concurrent和java.util.concurrent.lock包下 异步执行框架，提供了除Thread外一种新的异步执行框架，线程池是这里面提供的核心实现。包括了Executor、Fucture和ThreadPoolExecutor等，这些被放在了java.util.concurrent包下 当然每个人组织知识的方式的不一样所以上面这个分类纯属于个人理解并不表示一定正确，有不同看法的欢迎拍砖 说回ThreadPoolExecutor来，下面是通过IDEA得到的ThreadPoolExecutor的类图 这个类图属于上面所说的异步执行框架的一部分。看过一些文章则把这个归类成了线程池，但是个人觉得这种说法并不是很正确，实际上在ThreadPoolExecutor之上的各个类或接口都没有定义任何跟线程池相关的方法或属性，真正实现了线程池功能的是ThreadPoolExecutor以及他的子类们，所以这里关系是Executor定义了一种执行器接口，而ThreadPoolExecutor则仅是作为以线程池方式的一种实现，当然在并发包中也就线程池这么一种实现，不过如果就因为这样就把这个类图归为线程池还是觉得不是很合适的。然后这个类体系和以Future为父接口的类体系一起组成了一种新的异步编程的方式（不过Executor的源码注释里也说了Executor完全可以不用异步的方式，但是如果不用异步的方式其实也就没什么意义了，所以就不去考虑那种情况了）。至于为什么要重新这么一种新的方式，在Executor的源码注释也说的很清楚了: An object that executes submitted {@link Runnable} tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc 主要就是为了解耦任务的提交和任务实际的执行、线程调度等细节，还有就是通过Future来感知异步任务的执行情况、执行结果等。他提供的是Thread方式外的另一种异步执行的框架，做下简单对比: 异步执行任务【这个基本是废话 - -！，不过这边还是说下就是Thread方式也是可以做到执行过程和任务提交解耦的，就是通过new Thread的时候传入Runnable对象，不过如果是通过Thread重写run方法的话那任务的提交和执行便耦合了，所以很多地方才会建议启动Thread时通过传入Runnable对象】 判断/控制异步任务的生命周期【Thread可以通过start、stop、interrupt等方法来进行控制；ExecutorService可以通过submit、shutdown等方法来控制】 感知异步结果【这个通过Tread我们是无法直接实现的，一般如果需要感知到异步结果的话都会通过共享变量的方式来实现；ExecutorService通过submit方法会返回Future对象，一个表示异步执行结果的对象】 批量执行异步任务【这个通过Thread方式的话我们需要new多个Thread对象，自然这些线程的调度也需要我们编码来实现；ExecutorService提供了invokeAll的方法支持了批量提交，因为这个框架里任务提交和任务执行、调度是解耦开的，所以调度会由框架来执行，当然因为默认实现也就一种所以自然是通过线程池的方式来调度了】 定时/延时任务【这个在Thread中是没有直接支持的，通常会借助Timer等工具类来实现；ScheduledExecutorService提供了定时、延时功能，自然调度的细节也是解耦开的由框架实现了】 拓展:java中的并发/并行编程方式具体可以参考这篇文章Java并发的四种风味 最后说源码之前在简单的说下线程池吧。线程池其实就是池化技术的一种，一般用于对创建和销毁代价都比较高的系统资源做缓存用的，比如IO、线程等，以提高重复利用率避免代价比较比较高的创建和销毁。说白了当我们需要线程来执行任务时向线程池申请，线程池会判断还有没有空闲的线程，如果有就直接把这个线程给我们使用，如果没有就创建一个来给我们使用，当我们使用完之后就把线程在扔回给线程池，线程池会缓存这些线程以供下次申请使用，这是最简单的线程池模型了，不考虑线程池大小，存活时间等。这里想强调一下的就是线程≠任务，因为本人在刚开始阅读源码的时候这个地方没理解清楚踩了点坑，任务是我们提交的希望被执行的那部分代码，而线程则是用来运行这部分代码的上下文(不清楚上下文说的准不准确，想不出词了)。一般任务由我们书写提交，而线程则由线程池在内部维护，包括创建、调度、销毁等。废话了一大堆，下面开始说下源码，下面的内容是这样组织的: ThreadPoolExecutor构造函数的参数说明，因为ThreadPoolExecutor的参数是比较重要的，包括了几乎所有我们可以配置的项 ThreadPoolExecutor内部使用的关键属性、变量 ThreadPoolExecutor的核心逻辑，包括线程池的启动、任务提交、线程调度、任务执行、线程池关闭等 构造函数和关键属性构造函数: 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor一共4个构造函数,但最终都会调用上面这个构造函数,其中: corePoolSize 这个是用来控制池中工作线程个数的参数 maximumPoolSize 这个也是用来控制工作线程个数参数,表示的是最大线程数 上面两个参数都是用来控制控制工作线程的参数,但是他们的含义是有差别的 －①－(corePoolSize)－②－(maximumPoolSize)－③— 有点类似上面的一条直线,corePoolSize和maximumPoolSize切直线为三段①、②、③。当池内的工作线程数处于①这个区间内时线程池会在接收到任务时持续增长到corePoolSize大小(不会利用已有的线程及即使存在空闲的线程);然后线程池的线程个数会慢慢增长到②这个区间,这时线程池会在每次接受到任务时会优先查找池内的空闲线程,只有在找不到空闲线程时才增加新线程到线程池中执行新任务;最后一旦线程池增大到maximumPoolSize的大小时,线程池会开始拒绝执行新任务(拒绝策略可配置),所以线程个数时不会处于③区间的，达到③的情况时会执行拒绝策略。 keepAliveTime 这个是用来控制池内空闲线程存活时间的,这个参数在前面讲到的线程个数处于①区间时是不起作用的 unit 这个和keepAliveTime配合使用的,表示时间的单位 threadFactory 采用工厂模式生成线程,可以看下ThreadFactory接口其实就一个newThread方法，这样如果我们需要自定义线程池的生成方式的时就可以实现了。 handler 这个就是达到③这种情况时会执行的拒绝策略 理论上而会出现线程拒绝任务的情况需要满足两个条件,除了上面讨论到的线程个数达到了maximumPoolSize之外,还需要任务队列也满了才会出现拒绝的情况。不过事实上一旦线程达到maximumPoolSize的话队列肯定也是满的,这是因为代码前后逻辑顺序的原因,后面看代码就会知道。至于具体的策略,官方提供了四种AbortPolicy(默认,在调用线程内抛异常)、CallerRunsPolicy(在调用线程内执行该任务)、DiscardPolicy(简单抛弃不做任何事)、DiscardOldestPolicy(抛弃任务队列中最旧执行当前任务) 构造函数的几个参数提供了我们可配置的选项，除了这些可控参数还有几个线程池内部使用重要的属性和变量 ctl 一个控制变量,包含了线程池的状态信息和线程的数量信息，注意这个变量包含了两种信息：线程池状态和线程池内工作线程数量 12345678910private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 可以看出线程池的状态有5种——RUNNING, SHUTDOWN, STOP, TIDYING, TERMINATED RUNNING : 运行正常,可以正正常接受新任务SHUTDOWN : 不接受新任务,执行已缓存的任务然后关闭线程池STOP : 不接受新任务,中断已缓存的任务然后关闭线程池TIDYING : 当任务都结束了(正常执行完/中断完),即SHUTDOWN和STOP状态后面都会到TIDYING状态TERMINATED : 这个是因为提供了terminated()钩子函数,所以只有在执行了这个函数之后才会到TERMINATED状态;不过默认实现TIDYING状态即正常关闭了因为erminated()是个空方法 需要注意的是状态信息是和线程池的线程个数一起存放在了ctl属性里,其中高3位表示状态信息;低29位表示工作线程个数,共可表示2^29-1个线程大小。 至于为什么要用3位来表示状态，其实也很简单因为状态有5种2位最多表示4种明显存不下，所以最少都需要3位。而这些状态在内存中表示也可以计算一下：因为计算机内部使用补码存放，-1补码 -&gt; 0xffff，0 -&gt; 0x0000,1 -&gt; 0x0001,2 -&gt; 0x0002,3 -&gt; 0x0003,左移29位后，-1高三位 -&gt; 111，0 -&gt; 000,1 -&gt; 001,2 -&gt; 002,3 -&gt; 003，所以根据高三位不同就可以区分出不同的状态了，同时因为RUNNING状态被设计为负数，这种正常状态也可以很容易和其他状态区分开(&gt;0即可)，而线程池数的增加只需要低位每次增加就可以了，并不会影响到存储状态的高三位。所以这种设计的还是非常巧妙的，缺点就是可读性有点低 - -！。下面是关于这个属性的一些操作，可以看到基本上都是需要保证原子性的一些操作。 123456789101112131415161718192021222324252627//取高3位得到状态信息 c &amp; 0x70000000private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; //取低29位得到数量信息 c &amp; 0x07777777private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//状态信息和数量信息合并存于ctlprivate static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;//数量加1,可以发现只需要ctl+1即可private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1); &#125;//数量减1,同上只需要ctl-1即可private boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1); &#125;private void decrementWorkerCount() &#123; do &#123;&#125; while (!compareAndDecrementWorkerCount(ctl.get())); &#125;//下面几个是静态方法主要用来判断的private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125; workQueue 这个是用来存放执行任务的阻塞队列 其实个人觉得这个参数的命名并不准确,这个应该称为taskQueue会更合适一点，就是上面强调的任务和线程时不一样的，这个指的是任务，命名workQueue挺让人误解的;需要注意的是这个任务队列和corePoolSize、maximumPoolSize是没有关系的,这两个参数表示的是工作线程的容量大小,是和下面会说到的works的大小相关的;而队列相关是执行的任务,执行任务本身是不会启动线程的(可以试下直接调用Runnable的run是不启动新线程的),这些是在worker启动的线程中被执行的 workers 存放缓存线程的集合 这个才是和corePoolSize、maximumPoolSize是有关系的,表示的是工作线程的集合。但是实际上真正启动线程的是worker内部类型为Thread的一个参数t,就是ThreadFactory返回的那个线程,而newThread方法传入的参数就是worker本身。所以可以尝试下,如果自定义实现ThreadFactory,然后在返回线程时不使用传入的那个Runnable参数这时线程池是不会正常工作的。代码如下 123456789101112131415161718192021222324252627private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; private static final long serialVersionUID = 6138294804551838833L; //这里就是通过工厂返回的线程对象 final Thread thread; //这里就是该工作线程第一个执行的任务&#123;注意这里用词:第一个&#125; Runnable firstTask; //一个统计信息 volatile long completedTasks; Worker(Runnable firstTask) &#123; setState(-1); this.firstTask = firstTask; //就是在这里调用了工厂生成线程 this.thread = getThreadFactory().newThread(this); &#125; //这里就是线程具体执行的地方了,他调用了ThreadPoolExecutor的方法runWorker方法;当然前提是工厂的返回的线程要基于传入的Runnable也就是worker本身来生成线程 public void run() &#123; runWorker(this); &#125; ... &#125; mainLock 这个是内部使用的一个锁 123private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();private final Condition termination = mainLock.newCondition();private int largestPoolSize; 这里特地列出了上面三个属性,可以观察到这三个属性是线程不安全的,既然扯到线程不安全就很明显了,对这三个属性的操作是需要同步的。而到观察源码也可以发现锁的使用基本就是在处理这三个参数的时候了,不过有少数几个情况的锁的使用可以拿出来探讨的,后面再说 核心逻辑启动线程池 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //A. int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //B. if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //C. else if (!addWorker(command, false)) reject(command); &#125; 上面是启动线程池的方法(submit也是调用的该方法的),这个方法里主要有三种情况,对应A、B、C三处代码(源码英文注释也有说) A : 这个比较好理解，其实就对应着前面①的情况,这个时候时候无论有没有空闲线程都是需要新增工作线程的B : 这个是②的情况,任务队列是可以插入任务的;会发现即使插入成功后还是会在做一次判断,这是因为在并发环境下我们无法预测执行的操作,可能在插入成功后,有个操作把线程池给停了(而且在插入成功后执行了),根据状态的定义处于不处于RUNNING状态的话是不能接受新任务的,所以需要把任务取消掉;又或者插入成功后,工作线程刚好都因为空闲且超出了KeepAlive时间而被关闭了,我们知道任务是不启动新线程的,所以即使插入了任务但是没有活跃的工作线程也无法执行,所以需要添加一个新的工作线程C : 这个是处于②或③的情况。②是因为队列满了不过线程池还没满可以在增加线程;③其实就是队列满了线程池也满了,这个时候是肯定会执行reject的下面是具体如何添加工作线程的方法addWorker。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private boolean addWorker(Runnable firstTask, boolean core) &#123; //第一部分 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; //第二部分 boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; 这个方法很长,不过也不清楚要去掉哪些就全部贴出来了.这个方法的逻辑主要分两部分,第一部分属于条件判断,判断是否可以执行第二部分的新增工作线程的逻辑。第一部分主要判断两方面–状态和工作线程个数,根据对线程池的状态定义只有RUNNING状态的线程池才会接受新任务,所以看那个好像很复杂的判断其实说的是1.如果线程池现在是RUNNING状态，ok状态判断通过直接往下去判断线程个数；2.在根据SHUTDOWN的定义，在这个状态下不再接受新任务但是需要执行完已有的任务，所以需要判断传进来是不是空任务(会有这种情况的只希望开启一个新的工作线程而不指定新任务)且已有的任务队列是否还有没执行完的任务，那么这时候还是可以接受新启一个工作线程；3.上面两个判断逻辑就是那个复杂的判断逻辑想判断的东西，状态判断完后就需要判断工作线程的个数了，这个判断就比简单了判断是否已经达到要求的最大线程数了，如果是那就不能再新增新线程了有区别的无非就是这个最大值是以核心线程数(corePoolSize)还是默认的最大线程数(maximumPoolSize)来计算而已，然后会执行工作线程+1的操作，注意这里其实实际还没执行添加工作线程池的动作，所以颇有悲观锁的意思啊。第二部分就是执行实际的添加工作线程的动作了，首先是生成了一个新的工作线程(woker)，然后便加上了锁了，至于为什么加锁呢，很明显看里面的代码有wokers这个变量就知道了，这个变量是线程不安全的，然后这里的动作就是wokers里面加个工作线程而已，一切操作没问题后就会启动新增的线程，然后在新启动的线程内就会开始执行任务的动作了。 关闭线程池 1234567891011121314151617181920212223242526272829public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); &#125; public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks; &#125; 有两种关闭线程的方法,他们最主要的区别就是会使得线程池处于不同的状态中,shutdown会使线程池处于SHUTDOWN状态,这时线程池不接受新任务但会执行完已有的任务;而shutdownNow则使线程池处于STOP状态,这时线程池不仅不接受新任务还会中断掉所有正在运行的线程,已保存但未执行的任务是不会执行的。然后最后二者都会调用tryTerminate方法使线程池处于TIDYING状态最后处于TERMINATED状态完全关闭。注意这里也加了锁，不过其实观察这里其实并没有使用到具体的线程不安全的变量，而在各个子方法内部对于使用到线程不安全的变量时也都会上锁，所以一开始我不是很理解这个为什么还要加上这么一个比较粗粒度的锁，后面自己思考了挺久的想出一个可能的解释，这里试着解释下还希望有看到的大牛帮忙解释下：首先是shutdown方法，我觉得这个方法主要是因为最后还执行了一个onShutdown钩子方法，而设计者并不知道重写这个钩子函数的人是否会在重写这个方法时自己去同步那些变量，所以为了避免错误就直接都上了锁算了(即使是这样粒度也还是太粗了 - -！)；而shutdownNow则是因为STOP状态是不接受新任务而且也要中断其他已在执行的任务，在这种语义下很明显就是希望其他的工作线程都停下了，所以直接就上了锁挂起所有的工作线程然后中断他们，反正一旦调用了这个方法不管工作线程执行的到什么程度都是要被中断的所以不如直接先申请个锁让其他所有竞争这个锁的工作线程都暂停了。不过其实个人还是觉得这个地方加这个粗粒度的锁真的需要吗？还是希望有大神来解答下 - -！。 任务如何被执行 上面主要讲的是工作线程的添加、启动、关闭等，但却没涉及到任务具体怎么执行。任务是在工作线程内被执行的，所以在Thread.start()之后就会开始执行具体的任务了(具体看上面的addWorker)。在线程池内部工作线程被抽象为一个叫Woker的对象，上面已经提到过了，这个对象内部持有一个具体的线程对象(thread)，还有一个woker被创建时指定的待执行任务(firstTask)，还有的就是做下具体执行了多少任务的统计变量completedTasks。Woker本身实现了Runnale接口，在构造Woker时会通过我们指定的线程工厂ThreadFactory来生成线程，通过传入Woker自身的实例，所以可以尝试下如果在ThreadFactory的newThread方法不使用传入的Runnable对象来生成线程的话线程池还会正常工作吗？然后在具体的Run方法中就是简单的调用了runWorker方法，所以执行任务的关键方法就是runWorker方法，如下: 123456789101112131415161718192021222324252627282930313233343536373839final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125; 可以看到这个方法核心逻辑是个循环, firstTask做为工作线程的第一个任务，也就是生成Woker时指定的任务(即execute或submit时传入的Runnable对象),而getTasks()主要是从任务队列中取出任务,所以这边的做法就是不断的从任务队列中拿出任务来执行,如果任务队列中没有任务了就跳出循环线程也就结束了。而循环内的逻辑是很简单的，就是调用task的run方法,加上前后的两个钩子方法beforeExecute/afterExecute。最后会执行线程退出方法，在这个方法里主要就是把这个工作线程的执行任务数加到整个线程池的执行任务统计变量上，然后从wokers里移除这个已经结束的线程，然后就是如果是在RUNNING状态或SHUBMIT状态因为这个时候需要执行完任务所以会判断是不是没了工作线程了但还有未执行的任务，是的话就新启一个工作线程来执行剩余的任务。可以注意到的是w.completedTasks++这个w.completedTasks并没有定义为原子操作类，因为在这个操作逻辑里是会上锁的w.lock(),所以这里就没必要使用原子操作类了。 keepAliveTime如何实现 说构造函数的时候时候到有个参数keepAliveTime,指的是空闲线程的存活时间。这个主要是在getTasks()方法里实现,记得上面执行任务的时候是不断循环来拿任务执行的，只有在获取不到任务时才退出线程。所以源码就在获取任务getTasks()中实现了这个存活时间的逻辑。具体如下: 12345678910111213141516171819202122232425262728293031323334353637private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 这个方法的核心逻辑又是个循环，循环内第一个判断的逻辑主要是当线程池当前是不是SHUTDOWN、RUNNING，因为只有两种状态可以继续执行已有的任务，不过如果任务队列如果已经空了这两种状态下执行的逻辑不一样，RUNNING会继续往下执行，SHUTDOWN会返回因为SHUTDOWN没有任务之后就是要关闭线程池了。接下去的一个timed就是用来表征这个时候是否需要进行存活判断，有两种情况：默认corePoolSize数量以下的线程时不会停止的，除非设置了allowCoreThreadTimeOut=ture；还有就是如果超过了corePoolSize数量的话超出的部分就需要进行存活性判断了。接下来就是判断是否退出工作线程的判断，当超出最大工作线程个数或已经等待时间超过规定的时间且当前工作线程个数大于1或已经没有任务的时候会退出工作线程。否则就继续往下执行，下面一个是判断是否超时的逻辑。利用了阻塞队列的poll方法，超时时间就是在构造函数时传入的keepAliveTime参数，正常情况是得到待执行的任务然后返回。 ExecutorsExecutors是并发包中提供的一个工具类，最常用的就是利用的他的静态工厂方法来生成线程池了(各种newXXXXXXX)，因为ThreadPoolExecutor的构造方法参数实在是有点都嘛！不过看过阿里最近出的编程规范的应该也知道他们是不建议使用这些静态工厂方法的，原因那里面也写了这里不再说了。因为这个类的源码没具体去看过所以就不具体说了等看了源码在来更新。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"并发包","slug":"并发包","permalink":"http://yoursite.com/tags/并发包/"},{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/线程池/"}]},{"title":"以后开始写博客吧","date":"2017-03-24T14:16:03.000Z","path":"2017/03/24/以后开始写博客吧/","text":"","tags":[]}]